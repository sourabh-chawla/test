"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deployAndSignMessage = deployAndSignMessage;
exports.deployAndSignTypedData = deployAndSignTypedData;
exports.confirmContractDeployment = confirmContractDeployment;
const serialize_erc6492_signature_js_1 = require("../../../auth/serialize-erc6492-signature.js");
const verify_hash_js_1 = require("../../../auth/verify-hash.js");
const contract_js_1 = require("../../../contract/contract.js");
const encode_js_1 = require("../../../transaction/actions/encode.js");
const read_contract_js_1 = require("../../../transaction/read-contract.js");
const encodeAbiParameters_js_1 = require("../../../utils/abi/encodeAbiParameters.js");
const hashMessage_js_1 = require("../../../utils/hashing/hashMessage.js");
const hashTypedData_js_1 = require("../../../utils/hashing/hashTypedData.js");
const calls_js_1 = require("./calls.js");
async function deployAndSignMessage({ accountContract, factoryContract, options, message, }) {
    const originalMsgHash = (0, hashMessage_js_1.hashMessage)(message);
    const is712Factory = await checkFor712Factory({
        factoryContract,
        accountContract,
        originalMsgHash,
    });
    let sig;
    if (is712Factory) {
        const wrappedMessageHash = (0, encodeAbiParameters_js_1.encodeAbiParameters)([{ type: "bytes32" }], [originalMsgHash]);
        sig = await options.personalAccount.signTypedData({
            domain: {
                name: "Account",
                version: "1",
                chainId: options.chain.id,
                verifyingContract: accountContract.address,
            },
            primaryType: "AccountMessage",
            types: { AccountMessage: [{ name: "message", type: "bytes" }] },
            message: { message: wrappedMessageHash },
        });
    }
    else {
        sig = await options.personalAccount.signMessage({ message });
    }
    const deployTx = (0, calls_js_1.prepareCreateAccount)({
        factoryContract,
        adminAddress: options.personalAccount.address,
        accountSalt: options.overrides?.accountSalt,
        createAccountOverride: options.overrides?.createAccount,
    });
    if (!deployTx) {
        throw new Error("Create account override not provided");
    }
    const initCode = await (0, encode_js_1.encode)(deployTx);
    const erc6492Sig = (0, serialize_erc6492_signature_js_1.serializeErc6492Signature)({
        address: factoryContract.address,
        data: initCode,
        signature: sig,
    });
    // check if the signature is valid
    const isValid = await (0, verify_hash_js_1.verifyHash)({
        hash: originalMsgHash,
        signature: erc6492Sig,
        address: accountContract.address,
        chain: accountContract.chain,
        client: accountContract.client,
    });
    if (isValid) {
        return erc6492Sig;
    }
    throw new Error("Unable to verify signature on smart account, please make sure the admin wallet has permissions and the signature is valid.");
}
async function deployAndSignTypedData({ accountContract, factoryContract, options, typedData, }) {
    const isSelfVerifyingContract = typedData.domain?.verifyingContract?.toLowerCase() ===
        accountContract.address?.toLowerCase();
    if (isSelfVerifyingContract) {
        // if the contract is self-verifying, we can just sign the message with the EOA (ie. adding a session key)
        return options.personalAccount.signTypedData(typedData);
    }
    const originalMsgHash = (0, hashTypedData_js_1.hashTypedData)(typedData);
    // check if the account contract supports EIP721 domain separator based signing
    const is712Factory = await checkFor712Factory({
        factoryContract,
        accountContract,
        originalMsgHash,
    });
    let sig;
    if (is712Factory) {
        const wrappedMessageHash = (0, encodeAbiParameters_js_1.encodeAbiParameters)([{ type: "bytes32" }], [originalMsgHash]);
        sig = await options.personalAccount.signTypedData({
            domain: {
                name: "Account",
                version: "1",
                chainId: options.chain.id,
                verifyingContract: accountContract.address,
            },
            primaryType: "AccountMessage",
            types: { AccountMessage: [{ name: "message", type: "bytes" }] },
            message: { message: wrappedMessageHash },
        });
    }
    else {
        sig = await options.personalAccount.signTypedData(typedData);
    }
    const deployTx = (0, calls_js_1.prepareCreateAccount)({
        factoryContract,
        adminAddress: options.personalAccount.address,
        accountSalt: options.overrides?.accountSalt,
        createAccountOverride: options.overrides?.createAccount,
    });
    if (!deployTx) {
        throw new Error("Create account override not provided");
    }
    const initCode = await (0, encode_js_1.encode)(deployTx);
    const erc6492Sig = (0, serialize_erc6492_signature_js_1.serializeErc6492Signature)({
        address: factoryContract.address,
        data: initCode,
        signature: sig,
    });
    // check if the signature is valid
    const isValid = await (0, verify_hash_js_1.verifyHash)({
        hash: originalMsgHash,
        signature: erc6492Sig,
        address: accountContract.address,
        chain: accountContract.chain,
        client: accountContract.client,
    });
    if (isValid) {
        return erc6492Sig;
    }
    throw new Error("Unable to verify signature on smart account, please make sure the admin wallet has permissions and the signature is valid.");
}
async function confirmContractDeployment(args) {
    const { accountContract } = args;
    const startTime = Date.now();
    const timeout = 60000; // wait 1 minute max
    const { isContractDeployed } = await Promise.resolve().then(() => require("../../../utils/bytecode/is-contract-deployed.js"));
    let isDeployed = await isContractDeployed(accountContract);
    while (!isDeployed) {
        if (Date.now() - startTime > timeout) {
            throw new Error("Timeout: Smart account deployment not confirmed after 1 minute");
        }
        await new Promise((resolve) => setTimeout(resolve, 500));
        isDeployed = await isContractDeployed(accountContract);
    }
}
async function checkFor712Factory({ factoryContract, accountContract, originalMsgHash, }) {
    try {
        const implementationAccount = await (0, read_contract_js_1.readContract)({
            contract: factoryContract,
            method: "function accountImplementation() public view returns (address)",
        });
        // check if the account contract supports EIP721 domain separator or modular based signing
        const is712Factory = await (0, read_contract_js_1.readContract)({
            contract: (0, contract_js_1.getContract)({
                address: implementationAccount,
                chain: accountContract.chain,
                client: accountContract.client,
            }),
            method: "function getMessageHash(bytes32 _hash) public view returns (bytes32)",
            params: [originalMsgHash],
        })
            .then((res) => res !== "0x")
            .catch(() => false);
        return is712Factory;
    }
    catch {
        return false;
    }
}
//# sourceMappingURL=signing.js.map